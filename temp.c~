CUDA_CALLABLE_MEMBER vec raytrace(vec origin, vec dir, size_t reflections,
                                  sphere* gpu_spheres, plane* gpu_plane) {
  
  // Keep track of the closest shape that is intersected by this ray
  int intersected = 0;
  float intersect_distance = 0;
  plane current_plane;
  sphere current_sphere;
  int plane_closer = 0;
  int sphere_index = 0;
  vec intersection = origin;

  while(reflection < MAX_REFLECTIONS) {
  
  // Normalize the direction vector
  dir = dir.normalized();
  
  // Loop over all spheres in the scene to find the closest intersection
 
  for(int i = 0; i < OBJ_NUM ; i++) {
    current_sphere = gpu_spheres[i];
    float distance = current_sphere.intersection(origin, dir);
    if(distance >= 0 && (distance < intersect_distance || !intersected)) {
      intersect_distance = distance;
      intersected = 1;
      sphere_index = i;
    }
  }
  
  // for the plane
  current_plane = *gpu_plane;
  float distance = current_plane.intersection(origin, dir);
  if(distance >= 0 && (distance < intersect_distance || !intersected)) {
    intersected = 2;
    intersect_distance = distance;
    plane_closer = 1;
    //intersected = &current_plane;
  }

  if(!intersected)
    return vec(AMBIENT, AMBIENT, AMBIENT);

  vec intersection = origin + dir * (intersect_distance - EPSILON);

  vec n;
  vec result;
  
  // Initialize the result color to the ambient light reflected in the shapes color
  if(intersected == 1) {
    result = gpu_spheres[sphere_index].get_color(intersection) * AMBIENT;
  }
  else {
    result = current_plane.get_color(intersection) * AMBIENT;
  }

    // Find the normal at the intersection point
    if(intersected == 1) {
      n = gpu_spheres[sphere_index].normal(intersection);
    }
    else {
      n = current_plane.normal(intersection);
    }

    // Reflect the vector across the normal
    dir = dir - n * 2.0 * n.dot(dir);
      
    // Compute the reflected color by recursively raytracing from this point
    vec reflected = raytrace(intersection, new_dir, reflections + 1, gpu_spheres, gpu_plane);
  
    // Add the reflection to the result, tinted by the color of the shape
    if(intersected == 1) {
      result += reflected.hadamard(gpu_spheres[sphere_index].get_color(intersection)) *
        gpu_spheres[sphere_index].get_reflectivity();
    }
    else {
      result += reflected.hadamard(current_plane.get_color(intersection)) *
        current_plane.get_reflectivity();
    }
  }
  }
  return result;
}
